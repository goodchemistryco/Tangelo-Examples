<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Fault Tolerant Building blocks</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-sidebar docked nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark border-bottom">
      <div class="navbar-container container-fluid">
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html" rel="" target="">
 <span class="menu-text">Home</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools ms-auto">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../hands_on/T1_circuits.html">Hands On</a></li><li class="breadcrumb-item"><a href="../hands_on/T5_fault_tolerant_build_blocks.html">Fault Tolerant Building blocks</a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation docked overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Examples</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="false">
 <span class="menu-text">Chemistry</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/chemistry/excited_states.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Excited States in Tangelo</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/chemistry/qchem_modelling_basics.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Quantum Chemistry: Modelling Basics</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="false">
 <span class="menu-text">Fault Tolerant</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/fault_tolerant/qsp_state_prep.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">State preparation using quantum signal processing</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="false">
 <span class="menu-text">Hardware Experiments</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/hardware_experiments/berylium_ibm_quantum.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Combining Tangelo, QEMIST Cloud and IBM Quantum for quantum experiments</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/hardware_experiments/overview_endtoend.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">End-to-end Quantum Chemistry Workflow on Quantum Hardware with Tangelo</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/hardware_experiments/qemist_cloud_hardware_experiments_braket.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Submitting quantum hardware experiments with Tangelo and QEMIST Cloud</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/hardware_experiments/umbrella_inversion.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Exploring the umbrella inversion with quantum computers</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="false">
 <span class="menu-text">Measurement Reduction</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/measurement_reduction/classical_shadows.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Classical Shadows</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" aria-expanded="false">
 <span class="menu-text">Problem Decomposition</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/problem_decomposition/dmet.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Density Matrix Embedding Theory (DMET)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/problem_decomposition/dmet_uhf.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Applying Unrestricted Density-Matrix Embedding Theory to battery chemistry</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/problem_decomposition/mifno.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Exploring the Method of Increments with QEMIST Cloud and Tangelo</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/problem_decomposition/oniom.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">ONIOM Problem Decomposition - A use case for an acetic acid molecule in water</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" aria-expanded="false">
 <span class="menu-text">Variational Methods</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-7" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/variational_methods/adapt.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">ADAPT-VQE</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/variational_methods/iqcc_using_clifford.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Iterative Qubit Coupled Cluster using only Clifford circuits</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/variational_methods/vqe.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">VQE with Tangelo</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/variational_methods/vqe_custom_ansatz_hamiltonian.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tangelo VQE: Custom Ansatz and qubit Hamiltonian Tutorial</span></a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-8" aria-expanded="false">
 <span class="menu-text">Workflow Basics</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-8" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-8" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/workflow_basics/1.the_basics.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Linq: the basics</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/workflow_basics/2.qpu_connection.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Connecting to quantum services with Tangelo</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/workflow_basics/3.noisy_simulation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Linq: noisy simulation</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../examples/workflow_basics/symbolic_simulator.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Performing symbolic simulation in Tangelo</span></a>
  </div>
</li>
      </ul>
  </li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-9" aria-expanded="true">
 <span class="menu-text">Hands On</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-9" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-9" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../hands_on/T1_circuits.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tangelo hands-on: gates and circuits</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../hands_on/T1_circuits_solved.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tangelo hands-on: gates and circuits</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../hands_on/T2_simulators.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tangelo hands-on: simulating quantum circuits</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../hands_on/T2_simulators_solved.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tangelo hands-on: simulating quantum circuits</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../hands_on/T3_VQE.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tangelo hands-on: VQE framework</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../hands_on/T3_VQE_solved.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tangelo hands-on: VQE framework</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../hands_on/T4_hardware_experiments.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tangelo hands-on: hardware experiments</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../hands_on/T4_hardware_experiments_solved.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tangelo hands-on: hardware experiments</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../hands_on/T5_fault_tolerant_build_blocks.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Fault Tolerant Building blocks</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../hands_on/T5_fault_tolerant_build_blocks_solved.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Fault Tolerant Building blocks</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Fault Tolerant Building blocks</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="before-you-jump-in" class="level2">
<h2 class="anchored" data-anchor-id="before-you-jump-in">Before you jump in</h2>
<p>This hands-on notebook complements existing tutorials, documentation and the developer notes available in the Tangelo GitHub repositories, which present content in much more depth.</p>
<p>You will come across code cells that require you to change code or fill in the blanks in order to achieve a desired outcome. There may be many ways to solve these small exercises, and you are encouraged to explore.</p>
<p>In order to complete this hands-on tutorial, we recommend you install the latest version of Tangelo. If you encounter errors related to missing Python packages (classical chemistry backend, quantum circuit simulator…), you can install them on-the-fly by typing <code>!pip install &lt;package-name&gt;</code> in a new code cell, and then restart the Jupyter notebook kernel.</p>
<p>Have fun !</p>
<hr>
<p>For this hands-on, the following resources you can rely on to complete the hands-on are: - the first part of this <a href="https://github.com/goodchemistryco/Tangelo-Examples/blob/main/examples/workflow_basics/1.the_basics.ipynb">tutorial notebook</a> on <code>linq</code>, about gates and circuits. - the documentation for the <code>Gate</code> (<a href="http://tangelo-docs.goodchemistry.com/tangelo.linq.html#module-tangelo.linq.gate">here</a>) and <code>Circuit</code> (<a href="http://tangelo-docs.goodchemistry.com/tangelo.linq.html#module-tangelo.linq.circuit">here</a>) classes.</p>
<hr>
</section>
<section id="hands-on" class="level2">
<h2 class="anchored" data-anchor-id="hands-on">Hands-On</h2>
<p>Unlike NISQ algorithms which utilize short circuits and many measurements, fault-tolerant algorithms use long circuits and few measurements. The quantum computer can efficiently store large (exponential) systems efficiently but preparing these states is time-consuming and we generally don’t need all the information about the state.</p>
<section id="controlled-operations" class="level3">
<h3 class="anchored" data-anchor-id="controlled-operations">1. Controlled Operations</h3>
<p>A main component of fault-tolerant algorithms is controlled operations. These are defined such that operations given a state of a certain (set of) qubit(s), one can apply an operation to a different set of qubits. For example, the usual CNOT (CX) Gate applies X to the target qubit only if the first qubit is in the <span class="math inline">\(\big|1\big&gt;\)</span> state. This can be written as</p>
<p><span class="math inline">\(CX\big|0\big&gt;\big|s\big&gt;=\big|0\big&gt;\big|s\big&gt;, \quad CX\big|1\big&gt;\big|s\big&gt;=\big|1\big&gt;X\big|s\big&gt;\)</span></p>
<p>where <span class="math inline">\(s\)</span> is any state <span class="math inline">\(a\big|0\big&gt; + b\big|1\big&gt;\)</span>.</p>
<p>Likewise, this can be generalized to multiple controlled operations.</p>
<p>For example, if we want to apply an operation U only when the first 2-qubits are in state 1. We can define</p>
<p><span class="math inline">\(U^{01}\big|11\big&gt;\big|s\big&gt;=\big|11\big&gt;U\big|s\big&gt;\)</span></p>
<p>In general the operation can be controlled on many qubits and the state <span class="math inline">\(s\)</span> can be many qubits.</p>
<blockquote class="blockquote">
<p><strong>Q:</strong> Can you fill in the blanks in the cell below, to run the algorithm for a controlled-X gate. Remember that in Tangelo, the “C” in front of a gate dictates that a controlled operation is requested</p>
</blockquote>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> product</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.linq <span class="im">import</span> Circuit, Gate, get_backend</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>sim <span class="op">=</span> get_backend()</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>cx <span class="op">=</span> Circuit([Gate(<span class="st">""</span>, , control<span class="op">=</span>[])])</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Run through combinations of all states and print the result</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> states <span class="kw">in</span> product([<span class="st">"0"</span>, <span class="st">"1"</span>], repeat<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    f, _ <span class="op">=</span> sim.simulate(Circuit([Gate(<span class="st">"X"</span>, i<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> i, state  <span class="kw">in</span> <span class="bu">enumerate</span>(states) <span class="cf">if</span> state <span class="op">==</span> <span class="st">"1"</span>])<span class="op">+</span>cx)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"The ancilla in the </span><span class="sc">{</span>states[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> state returns the frequencies </span><span class="sc">{</span>f<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Can you apply the operation controlled on qubits 1 and 2, such that the first qubit flips to state “1” only if qubits 1 and and 2 are in state “1”</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>sim <span class="op">=</span> get_backend()</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>ccx <span class="op">=</span> Circuit([Gate(<span class="st">""</span>, , control<span class="op">=</span>[, ])])</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> states <span class="kw">in</span> product([<span class="st">"0"</span>, <span class="st">"1"</span>], repeat<span class="op">=</span><span class="dv">2</span>):</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    f, _ <span class="op">=</span> sim.simulate(Circuit([Gate(<span class="st">"X"</span>, i<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> i, state  <span class="kw">in</span> <span class="bu">enumerate</span>(states) <span class="cf">if</span> state <span class="op">==</span> <span class="st">"1"</span>])<span class="op">+</span>ccx)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(states, f)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we can combine the operations which will only flip the state if the second and third qubits are in the state “10”</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> states <span class="kw">in</span> product([<span class="st">"0"</span>, <span class="st">"1"</span>], repeat<span class="op">=</span><span class="dv">2</span>):</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    f, _ <span class="op">=</span> sim.simulate(Circuit([Gate(<span class="st">"X"</span>, i<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> i, state  <span class="kw">in</span> <span class="bu">enumerate</span>(states) <span class="cf">if</span> state <span class="op">==</span> <span class="st">"1"</span>]) <span class="op">+</span> ccx <span class="op">+</span> cx)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(states, f)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In general, we can make more complicated controlled unitaries. One of the key fault-tolerant algorithms is phase-estimation. Which can approximate the eigenvalues of a state using a series of controlled operations follewed by a Quantum Fourier Transform.</p>
</section>
<section id="quantum-phase-estimation" class="level3">
<h3 class="anchored" data-anchor-id="quantum-phase-estimation">2. Quantum Phase Estimation</h3>
<p>The first fault-tolerant algorithm we will implement in phase-estimation. It is a technique to obtain the energy of an (approximate) eigenstate by a series of controlled time-evolutions of a Hamiltonian. The circuit is shown below</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="PE_Circuit.png" title="Quantum Phase Estimation Circuit" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">QPE Circuit</figcaption>
</figure>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> openfermion <span class="im">import</span> get_sparse_operator</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo <span class="im">import</span> SecondQuantizedMolecule</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.linq <span class="im">import</span> get_backend, Circuit, Gate</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.toolboxes.qubit_mappings.mapping_transform <span class="im">import</span> fermion_to_qubit_mapping</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.toolboxes.qubit_mappings.statevector_mapping <span class="im">import</span> get_reference_circuit</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Define H2 molecule in minimal basis set</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>xyz_H2 <span class="op">=</span> [(<span class="st">"H"</span>, (<span class="fl">0.</span>, <span class="fl">0.</span>, <span class="fl">0.</span>)), (<span class="st">"H"</span>, (<span class="fl">0.</span>, <span class="fl">0.</span>, <span class="fl">0.7414</span>))]</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>mol_H2_sto3g <span class="op">=</span> SecondQuantizedMolecule(xyz_H2, q<span class="op">=</span><span class="dv">0</span>, spin<span class="op">=</span><span class="dv">0</span>, basis<span class="op">=</span><span class="st">"sto-3g"</span>)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>mol <span class="op">=</span> mol_H2_sto3g</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Qubit operator representing H2 in a minimal basis</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>qu_op <span class="op">=</span> fermion_to_qubit_mapping(mol.fermionic_hamiltonian, mapping<span class="op">=</span><span class="st">"JW"</span>, n_spinorbitals<span class="op">=</span>mol.n_active_sos, n_electrons<span class="op">=</span>mol.n_active_electrons, spin<span class="op">=</span>mol.spin, up_then_down<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Cheat to get the ground state eigenvalue to be 0.25. The exact ground state energy is 1.137270174660903</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>qu_op <span class="op">+=</span> (<span class="fl">0.25</span> <span class="op">+</span> <span class="fl">1.137270174660903</span>)</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>eigs, statevectors <span class="op">=</span> np.linalg.eigh(get_sparse_operator(qu_op).toarray())</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>ground_sv <span class="op">=</span> statevectors[:, <span class="dv">0</span>]</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>first_sv <span class="op">=</span> statevectors[:, <span class="dv">13</span>]  <span class="co"># due to the Jordan-Wigner mapping being used, there are many states that have the wrong number of electrons so 13 is the first excited state with 2 electrons</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Hartree-Fock reference state circuit</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>hf_circuit <span class="op">=</span> get_reference_circuit(n_spinorbitals<span class="op">=</span>mol.n_active_sos, n_electrons<span class="op">=</span>mol.n_active_electrons, mapping<span class="op">=</span><span class="st">"JW"</span>,</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>                                   up_then_down<span class="op">=</span><span class="va">False</span>, spin<span class="op">=</span>mol.spin)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>sim <span class="op">=</span> get_backend(<span class="st">"cirq"</span>)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>f, hf_sv <span class="op">=</span> sim.simulate(hf_circuit, return_statevector<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>g_ovlp <span class="op">=</span> np.dot(hf_sv, ground_sv)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>f_ovlp <span class="op">=</span> np.dot(hf_sv, first_sv)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The overlap of the initial (Hartree-Fock) state with the exact ground state is </span><span class="sc">{</span>g_ovlp<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The overlap of the initial (Hartree-Fock) state with the exact first excited state is </span><span class="sc">{</span>f_ovlp<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<blockquote class="blockquote">
<p><strong>Q:</strong> Can you fill in the blanks in the cell below, to run the algorithm. You may need to change the parameters used in the Trotter-Suzuki (trotterize) operation to obtain accurate enough time-evolution to get a good result.</p>
</blockquote>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.toolboxes.ansatz_generator.ansatz_utils <span class="im">import</span> trotterize, get_qft_circuit</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.toolboxes.post_processing.histogram <span class="im">import</span> Histogram</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Reverse order as cirq uses lsq_first</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>qubit_list <span class="op">=</span> [<span class="dv">6</span>, <span class="dv">5</span>, <span class="dv">4</span>]</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co"># State preparation</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>pe_circuit <span class="op">=</span> hf_circuit <span class="op">+</span> Circuit([Gate(<span class="st">"H"</span>, q) <span class="cf">for</span> q <span class="kw">in</span> qubit_list ])</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, qubit <span class="kw">in</span> <span class="bu">enumerate</span>(qubit_list):</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># You can play around with how accurate the time-evolution needs to be</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Use negative time as trotterize uses exp(-iHt) to follow the Schrodinger equation</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    pe_circuit <span class="op">+=</span> trotterize(qu_op, trotter_order<span class="op">=</span>, n_trotter_steps<span class="op">=</span>, time<span class="op">=</span>, control<span class="op">=</span>qubit)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="co"># set inverse to true or false</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>pe_circuit <span class="op">+=</span> get_qft_circuit(qubit_list, inverse<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>sim <span class="op">=</span> get_backend(<span class="st">"cirq"</span>)</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>freqs, _ <span class="op">=</span> sim.simulate(pe_circuit)</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Remove qubit indices from histogram corresponding to the state qubits i.e. (0, 1, 2, 3)</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>hist <span class="op">=</span> Histogram(freqs)</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>hist.remove_qubit_indices(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> key, probability <span class="kw">in</span> hist.frequencies.items():</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>      energy <span class="op">=</span> <span class="bu">sum</span>(<span class="bu">int</span>(k)<span class="op">/</span><span class="dv">2</span><span class="op">**</span>(i<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> i, k <span class="kw">in</span> <span class="bu">enumerate</span>(key))</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>      <span class="bu">print</span>(<span class="ss">f"The measurement </span><span class="sc">{</span>key<span class="sc">}</span><span class="ss"> with probability </span><span class="sc">{</span>probability<span class="sc">:3.5f}</span><span class="ss"> converts to an energy=</span><span class="sc">{</span>energy<span class="sc">}</span><span class="ss"> "</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>As desired, the most probable result was “010” with energy 0.25. We can run the circuit agains specifying this is the result we want and then examine the statevector that results.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>desired_measurement <span class="op">=</span> <span class="st">"010"</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>pe_plus_measure <span class="op">=</span> pe_circuit <span class="op">+</span> Circuit([Gate(<span class="st">"MEASURE"</span>, i) <span class="cf">for</span> i <span class="kw">in</span> qubit_list])</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>_, sv_new <span class="op">=</span> sim.simulate(pe_plus_measure, desired_meas_result<span class="op">=</span>desired_measurement, return_statevector<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The probability of this measurement is </span><span class="sc">{</span>pe_plus_measure<span class="sc">.</span>success_probabilities[desired_measurement]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Shrink vector down to 2**4 size to compare with exact ground state.</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>sv_new_post <span class="op">=</span> np.reshape(sv_new, (<span class="dv">2</span><span class="op">**</span><span class="dv">4</span>, <span class="dv">2</span><span class="op">**</span><span class="dv">3</span>))[:, <span class="bu">int</span>(desired_measurement, base<span class="op">=</span><span class="dv">2</span>)]</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The final state overlap with the ground state is </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">abs</span>(np.dot(sv_new_post, ground_sv))<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can see that we measured the desired energy with probability 0.987 and the resulting state has overlap with the exact state of 0.99997 while it started with an overlap of 0.9936. We not only measured the energy of an eigenstate, we also created the eigenstate on the simulator. This eigenstate can then be used to perform other tasks!</p>
</section>
<section id="block-encodings." class="level3">
<h3 class="anchored" data-anchor-id="block-encodings.">3. Block encodings.</h3>
<p>Another building block of many fault-tolerant algorithms is block encodings. This is a technique to implement any operation as long as it can be decomposed into a linear combination of Unitaries. We can implement the operation using <span class="math inline">\(U_{prep}\)</span> and <span class="math inline">\(U_{select}\)</span> defined for a general operator <span class="math inline">\(A=\sum_i c_i U_i\)</span> where <span class="math inline">\(U_i\)</span> are unitaries.</p>
<p><span class="math inline">\(U_{prep}\big|\psi\big&gt;\big|0\big&gt; = \sum_{i}\sqrt{|c_i|/\alpha}\big|\psi\big&gt;\big|i\big&gt;\)</span></p>
<p><span class="math inline">\(U_{select}\big|\psi\big&gt;\big|i\big&gt; = U_i\big|\psi\big&gt;\big|i\big&gt;\)</span></p>
<p>where <span class="math inline">\(\alpha\)</span> is the 1-norm of the coefficients <span class="math inline">\(|c_i|\)</span></p>
<p>Applying the circuit <span class="math inline">\(U_{prep}U_{select}U_{prep}^{\dagger}\)</span> results in <span class="math inline">\(A\big|\psi\big&gt;\big|0\big&gt; + \sum_i \big|\psi^{\perp}\big&gt;\big|i\big&gt;\)</span> where <span class="math inline">\(\psi^{\perp}\)</span> are states orthogonal to <span class="math inline">\(A\psi\)</span>. This means that if we measure the ancilla qubits and the result is zero, we have successfully applied the desired operation <span class="math inline">\(A\)</span>.</p>
<p>For example, let’s try to apply <span class="math inline">\(A=\frac{1}{\sqrt{2}}X+\frac{1}{\sqrt{2}}Y\)</span> which is equivalent to <span class="math inline">\(\left[\begin{array}{cc}0&amp;1/2-1/2\\ 1/2+i/2&amp;0\end{array}\right]\)</span></p>
<blockquote class="blockquote">
<p><strong>Q:</strong> Can you fill in the blanks in the cell below, to apply the operation A defined as a linear combination of unitaries <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>.</p>
</blockquote>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.toolboxes.operators <span class="im">import</span> QubitOperator</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.linq.helpers.circuits.statevector <span class="im">import</span> StateVector</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>coefs <span class="op">=</span> [<span class="dv">1</span><span class="op">/</span>np.sqrt(<span class="dv">2</span>), <span class="dv">1</span><span class="op">/</span>np.sqrt(<span class="dv">2</span>)]</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> QubitOperator(<span class="st">"X0"</span>, coefs[<span class="dv">0</span>]) <span class="op">+</span> QubitOperator(<span class="st">"Y0"</span>, coefs[<span class="dv">1</span>])</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>vec <span class="op">=</span> np.array(np.<span class="bu">abs</span>(coefs))</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>vec <span class="op">=</span> np.sqrt(vec<span class="op">/</span>np.<span class="bu">sum</span>(vec))</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="co"># In this case prep can be be applied by simply applying the Hadamard gate to the first qubit</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>uprep <span class="op">=</span> Circuit([Gate(<span class="st">"H"</span>, <span class="dv">1</span>)])</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>sv <span class="op">=</span> StateVector(vec)</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>uprep <span class="op">=</span> sv.initializing_circuit()</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>uprep.reindex_qubits([<span class="dv">1</span>])</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Qubit 1 is the register with coefficients [1/sqrt(2), 1/sqrt(2)]</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>cy1 <span class="op">=</span> [Gate(<span class="st">""</span>, target<span class="op">=</span>, control<span class="op">=</span>[])]</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Sandwiching with "X" gates flips the control bit such that operation is controled on state "0"</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>cx0 <span class="op">=</span> [Gate(<span class="st">"X"</span>, <span class="dv">1</span>), Gate(<span class="st">""</span>, target<span class="op">=</span>, control<span class="op">=</span>[]), Gate(<span class="st">"X"</span>, <span class="dv">1</span>)]</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Uselect</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>uselect <span class="op">=</span> Circuit(cx0 <span class="op">+</span> cy1)</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>sim <span class="op">=</span> get_backend(<span class="st">"cirq"</span>)</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a><span class="co"># We will use this as a state prep circuit. You can change this to any set of operations on qubit 0</span></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>state_prep <span class="op">=</span> Circuit([Gate(<span class="st">"RY"</span>, <span class="dv">0</span>, parameter<span class="op">=</span>np.pi<span class="op">/</span><span class="dv">4</span>)])</span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>_, init_state <span class="op">=</span> sim.simulate(state_prep, return_statevector<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>block_circuit <span class="op">=</span> uprep <span class="op">+</span> uselect <span class="op">+</span> uprep.inverse() </span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>circuit <span class="op">=</span> state_prep <span class="op">+</span> block_circuit <span class="op">+</span> Circuit([Gate(<span class="st">"MEASURE"</span>, <span class="dv">1</span>)])</span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>desired_measurement <span class="op">=</span> <span class="st">"0"</span></span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a>f, sv <span class="op">=</span> sim.simulate(circuit, desired_meas_result<span class="op">=</span>desired_measurement, return_statevector<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a>final_state <span class="op">=</span> sv.reshape(<span class="dv">2</span>,<span class="dv">2</span>)[:,<span class="bu">int</span>(desired_measurement, base<span class="op">=</span><span class="dv">2</span>)]</span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The success probability of the operation was </span><span class="sc">{</span>circuit<span class="sc">.</span>success_probabilities[<span class="st">'0'</span>]<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>final_exact <span class="op">=</span> get_sparse_operator(a).toarray() <span class="op">@</span> init_state</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>final_exact <span class="op">/=</span> np.linalg.norm(final_exact)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The overlap of the exact with the block encoded application of A is </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">abs</span>(np.vdot(final_state, final_exact))<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>As you can see, we successfully applied the operation <span class="math inline">\(A\)</span> when the measurement on the ancilla (qubit 1) is “0”.</p>
</section>
<section id="amplitude-amplification" class="level3">
<h3 class="anchored" data-anchor-id="amplitude-amplification">4. Amplitude Amplification</h3>
<p>We would like to have a higher probability of success. This is the main point of grover search where <span class="math inline">\(\sqrt{N}\)</span> amplifications of the desired “good” state is required to increase the probability by <span class="math inline">\(N\)</span>. Hence, the quadratic speed up. To implement this we need to apply signed operations.</p>
<p><span class="math inline">\(F_{good} F_{full}\)</span></p>
<p>In this case, the “good” subspace is all zeros on the ancilla qubits and the full state is the application of the block encoding.</p>
<p>where <span class="math inline">\(F_{good} = (1-\big|0\big&gt;^{ancilla}\big&lt;0\big|^{ancilla})\)</span> and <span class="math inline">\(F_{full} = (1-A\big|\psi\big&gt;\big&lt;\psi\big|A)\)</span></p>
<blockquote class="blockquote">
<p><strong>Q:</strong> Can you fill in the blanks in the cell below to define the appropriate qubits and operation that the sign flip operations are applied to.</p>
</blockquote>
<p>In order to facilitate amplitude amplification, we are going to make the 1-norm of the operator 2 such that the success probability is 0.25. The operator being applied is <span class="math inline">\((I - I + X + Y)/\sqrt{2}\)</span>. After amplification, the operator will be applied with 100% probability.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tangelo.toolboxes.circuits.lcu <span class="im">import</span> sign_flip, get_uprep_uselect</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>uprep, uselect, state_qubits, ancilla_qubits, alpha <span class="op">=</span> get_uprep_uselect(a, make_alpha_eq_2<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> flip_on_state(qubits: <span class="bu">list</span>, circuit: Circuit):</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> circuit.inverse() <span class="op">+</span> sign_flip(qubits) <span class="op">+</span> circuit</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>block_circuit <span class="op">=</span> uprep <span class="op">+</span> uselect <span class="op">+</span> uprep.inverse()</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>full_circuit <span class="op">=</span> state_prep <span class="op">+</span> block_circuit</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Fill in this section</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>amplifying_circuit <span class="op">=</span> flip_on_state(, ) <span class="op">+</span> flip_on_state(, )</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>unamplified_circuit <span class="op">=</span> state_prep <span class="op">+</span> block_circuit <span class="op">+</span> Circuit([Gate(<span class="st">"MEASURE"</span>, q) <span class="cf">for</span> q <span class="kw">in</span> ancilla_qubits])</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>amplified_circuit <span class="op">=</span> state_prep <span class="op">+</span> block_circuit <span class="op">+</span> amplifying_circuit <span class="op">+</span> Circuit([Gate(<span class="st">"MEASURE"</span>, q) <span class="cf">for</span> q <span class="kw">in</span> ancilla_qubits])</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>f, sv <span class="op">=</span> sim.simulate(amplified_circuit, return_statevector<span class="op">=</span><span class="va">True</span>, desired_meas_result<span class="op">=</span><span class="st">"0"</span><span class="op">*</span><span class="bu">len</span>(ancilla_qubits))</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>amplified_final_state <span class="op">=</span> sv.reshape(<span class="dv">2</span>,<span class="dv">4</span>)[:,<span class="dv">0</span>]</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>f, sv <span class="op">=</span> sim.simulate(unamplified_circuit, return_statevector<span class="op">=</span><span class="va">True</span>, desired_meas_result<span class="op">=</span><span class="st">"0"</span><span class="op">*</span><span class="bu">len</span>(ancilla_qubits))</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>unamplified_final_state <span class="op">=</span> sv.reshape(<span class="dv">2</span>,<span class="dv">4</span>)[:,<span class="dv">0</span>]</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The overlap of the two states are </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">abs</span>(np.vdot(amplified_final_state, unamplified_final_state))<span class="sc">: 3.2f}</span><span class="ss">"</span>)</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The success probability has been increased from </span><span class="sc">{</span>unamplified_circuit<span class="sc">.</span>success_probabilities[<span class="st">'00'</span>]<span class="sc">: 3.2f}</span><span class="ss"> to "</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>      <span class="ss">f"</span><span class="sc">{</span>amplified_circuit<span class="sc">.</span>success_probabilities[<span class="st">'00'</span>]<span class="sc">: 3.2f}</span><span class="ss"> after amplitude amplification"</span>)</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The overlap of the amplified state with the exact state is </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">abs</span>(np.vdot(final_state, amplified_final_state))<span class="sc">: 3.2f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If implemented successfully, the probability should have increased from 0.25 to 1.0 while returning the correct state by only using one amplifying circuit. The quadratic speedup we required!</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>